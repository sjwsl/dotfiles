" common
language en_US.UTF-8
filetype plugin indent on
autocmd FileType latex,tex,md,markdown setlocal spell | setlocal spelllang=en_us,cjk
let mapleader=" "
set cmdheight=2
set cursorline
set encoding=utf-8
set hidden
set laststatus=2
set lazyredraw
set maxmempattern=2000000
set mouse=a
set nobackup
set noerrorbells
set noswapfile
set nowritebackup
set number
set pumheight=10
set relativenumber
set shortmess+=c
set showmatch
set splitright
set timeoutlen=1000
set ttimeoutlen=5
set updatetime=100
set wildmenu

call plug#begin('~/.vim/plugged')

Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'

Plug 'Chiel92/vim-autoformat'
nnoremap <silent> <leader>l :Autoformat<CR>

Plug 'Yggdroot/LeaderF'
let g:Lf_UseCache = 1
let g:Lf_PythonVersion = 3
let g:Lf_Gtagslabel = 'native-pygments'
let g:Lf_RgConfig = [
      \ "--hidden",
      \ "--max-columns=150",
      \ "--no-ignore"
      \ ]
let g:Lf_ExternalCommand = 'rg --files --no-ignore --hidden "%s"'
let g:Lf_PreviewInPopup = 1
let g:Lf_ShowHidden = 1
let g:Lf_RootMarkers = ['.project']
nnoremap <silent> <leader>s :<C-U><C-R>=printf("Leaderf rg -F -e %s", expand("<cword>"))<CR><CR>
xnoremap <silent> <leader>s :<C-U><C-R>=printf("Leaderf rg -F -e %s", leaderf#Rg#visual())<CR><CR>
noremap <silent> <leader>p :Leaderf rg -F<CR>
noremap <silent> <leader>r :<C-U><C-R>=printf("Leaderf gtags -r %s --auto-jump", expand("<cword>"))<CR><CR>
noremap <silent> <leader>R :<C-U><C-R>=printf("Leaderf gtags -s %s --auto-jump", expand("<cword>"))<CR><CR>
noremap <silent> <leader>d :<C-U><C-R>=printf("Leaderf gtags -d %s --auto-jump", expand("<cword>"))<CR><CR>
noremap <silent> <leader>g :Leaderf gtags<CR>
noremap <silent> <leader>m :Leaderf mru<CR>
noremap <silent> <leader>f :Leaderf file<CR>
noremap <silent> <leader>b :Leaderf buffer<CR>

Plug 'easymotion/vim-easymotion'
nmap <silent> s <Plug>(easymotion-bd-f)
nmap <silent> <Leader>w <Plug>(easymotion-bd-w)
let g:EasyMotion_smartcase = 1
let g:EasyMotion_startofline = 0 " keep cursor column when JK motion
let g:EasyMotion_do_mapping = 0

Plug 'junegunn/vim-easy-align'
xmap <silent> <leader>a <Plug>(EasyAlign)
nmap <silent> <leader>a <Plug>(EasyAlign)

Plug 'lervag/vimtex'
let g:tex_flavor='latex'
let g:vimtex_texcount_custom_arg=' -ch -total'
let g:vimtex_quickfix_open_on_warning=0

Plug 'mhinz/vim-signify'
let g:signify_sign_show_count = 1

Plug 'scrooloose/nerdcommenter'
" Create default mappings
let g:NERDCreateDefaultMappings = 1
" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1
" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1
" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'
" Set a language to use its alternate delimiters by default
let g:NERDAltDelims_java = 1
" Allow commenting and inverting empty lines (useful when commenting a region)
let g:NERDCommentEmptyLines = 1
" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace = 1
" Enable NERDCommenterToggle to check all selected lines is commented or not
let g:NERDToggleCheckAllLines = 1

Plug 'vim-airline/vim-airline'
let g:airline#extensions#whitespace#enabled = 0
let g:airline#extensions#scrollbar#enabled = 0

Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
Plug 'neovim/nvim-lspconfig'
Plug 'nvim-lua/completion-nvim'
Plug 'glepnir/lspsaga.nvim'

Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'morhetz/gruvbox'
Plug 'honza/vim-snippets'
Plug 'iamcco/markdown-preview.nvim', { 'do': 'cd app && yarn install'  }
Plug 'wakatime/vim-wakatime'

call plug#end()

lua << EOF
local nvim_lsp = require('lspconfig')

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
print('language server attached!')
local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

-- Mappings.
local opts = { noremap=true, silent=true }

-- See `:help vim.lsp.*` for documentation on any of the below functions
buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
end

-- Use a loop to conveniently call 'setup' on multiple servers and
-- map buffer local keybindings when the language server attaches
nvim_lsp["clangd"].setup {
  cmd = { "clangd", "--background-index", "--clang-tidy" },
  on_attach = on_attach,
}
EOF

lua <<EOF
local saga = require 'lspsaga'
saga.init_lsp_saga()
-- code action
EOF
nnoremap <silent> gh :Lspsaga lsp_finder<CR>
nnoremap <silent> gs :Lspsaga signature_help<CR>
nnoremap <silent><leader>q :Lspsaga code_action<CR>
vnoremap <silent><leader>q :<C-U>Lspsaga range_code_action<CR>
nnoremap <silent>K :Lspsaga hover_doc<CR>
nnoremap <silent> <C-f> <cmd>lua require('lspsaga.action').smart_scroll_with_saga(1)<CR>
nnoremap <silent> <C-b> <cmd>lua require('lspsaga.action').smart_scroll_with_saga(-1)<CR>
nnoremap <silent> <leader>rn :Lspsaga rename<CR>
nnoremap <silent> [g :Lspsaga diagnostic_jump_next<CR>
nnoremap <silent> ]g :Lspsaga diagnostic_jump_prev<CR>

lua <<EOF
require'nvim-treesitter.configs'.setup {
  highlight = {
  enable = true,
  -- Setting this to true will run `:h syntax` and tree-sitter at the same time.
  -- Set this to `true` if you depend on 'syntax' being enabled (like for indentation).
  -- Using this option may slow down your editor, and you may see some duplicate highlights.
  -- Instead of true it can also be a list of languages
  additional_vim_regex_highlighting = false,
  },
}
EOF

" Use completion-nvim in every buffer
autocmd BufEnter * lua require'completion'.on_attach()
" Use <Tab> and <S-Tab> to navigate through popup menu
inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
" Set completeopt to have a better completion experience
set completeopt=menuone,noinsert,noselect
" Avoid showing message extra message when using completion
set shortmess+=c
let g:completion_enable_auto_popup = 0
imap <tab> <Plug>(completion_smart_tab)
imap <s-tab> <Plug>(completion_smart_s_tab)

" for gruvbox
hi! link Comment GruvboxGray
hi! link Function GruvboxBlue
hi! link Macro GruvboxOrange
hi! link Constant GruvboxPurple
hi! link Number Constant
hi! link Boolean Constant
hi! link String Constant

hi! link LspCxxHlGroupNamespace GruvboxOrange
hi! link LspCxxHlGroupEnumConstant Constant
hi! link LspCxxHlGroupMemberVariable GruvboxFg4

" theme
set background=dark
colorscheme gruvbox
set termguicolors
hi Normal guibg=none
if (has("nvim"))
  let $NVIM_TUI_ENABLE_TRUE_COLOR=1
endif

" https://vi.stackexchange.com/questions/11903/working-directory-different-than-current-file-directory
set viewoptions-=curdir

" cursor shapes
let &t_EI = "\<esc>[2 q"
let &t_SI = "\<esc>[6 q"
let &t_SR = "\<esc>[6 q"

" fold
augroup fold
  au!
  au BufReadPre * setlocal foldmethod=indent
  au BufWinEnter * if &fdm == 'indent' | setlocal foldmethod=manual | endif
augroup end

" indent
set autoindent
set backspace=indent,eol,start
set expandtab
set shiftwidth=2
set softtabstop=2
set tabstop=2

" search
set hlsearch
set ignorecase
set incsearch
set smartcase
nnoremap <silent><expr> <Leader>h (&hls && v:hlsearch ? ':nohls' : ':set hls')."\n"

" netrw
noremap <silent> <leader>e :edit .<CR>
let g:netrw_banner = 0
let g:netrw_liststyle = 3

" imap
inoremap <ESC> <NOP>
inoremap <down> <NOP>
inoremap <left> <NOP>
inoremap <right> <NOP>
inoremap <up> <NOP>
inoremap jk <ESC>
inoremap kj <ESC>
inoremap {; {<CR>};<ESC>O
inoremap {, {<CR>},<ESC>O
inoremap {{ {<CR>}<ESC>O

" nmap
nnoremap <down> <NOP>
nnoremap <left> <NOP>
nnoremap <right> <NOP>
nnoremap <up> <NOP>
nnoremap Q <NOP>
nnoremap # #zz
nnoremap * *zz
nnoremap <C-I> <C-I>zz
nnoremap <C-O> <C-O>zz
nnoremap <silent> <C-W>\| :vsplit<CR>
nnoremap <silent> <C-W>_ :split<CR>
nnoremap cp "+y
nnoremap g# g#zz
nnoremap g* g*zz
nnoremap n nzz
nnoremap N Nzz

" Zoom / Restore window.
function! s:ZoomToggle() abort
  if exists('t:zoomed') && t:zoomed
    execute t:zoom_winrestcmd
    let t:zoomed = 0
  else
    let t:zoom_winrestcmd = winrestcmd()
    resize
    vertical resize
    let t:zoomed = 1
  endif
endfunction
command! ZoomToggle call s:ZoomToggle()
nnoremap <silent> <C-W>z :ZoomToggle<CR>

" xmap
xnoremap cp "+y
